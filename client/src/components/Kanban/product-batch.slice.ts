import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import update from 'immutability-helper';

import {
  type MutationCreateProductBatchArgs,
  // MutationMergeProductBatchArgs,
  MutationSplitProductBatchArgs,
  type MutationUpdateProductBatchArgs,
  type ProductBatch,
} from '../../gql-types/graphql';
import { type AppThunk, type RootState } from '../../redux-store';
import {
  createProductBatch,
  deleteProductBatch,
  fetchProductBatchList,
  // mergeProductBatch,
  splitProductBatch,
  updateProductBatch,
} from './product-batch.api';

export type ProductBatchItemState<T = ProductBatch> = T & {
  checked: boolean;
};

export interface ProductBatchState {
  items: ProductBatchItemState[];
  splitProductBatchForm: {
    item: ProductBatch;
    statusId: number;
  } | null;
  showModal: boolean;
}

const initialState: ProductBatchState = {
  items: [],
  splitProductBatchForm: null,
  showModal: false,
};

function buildProductBatchItemState(data: ProductBatch): ProductBatchItemState;
function buildProductBatchItemState(
  data: ProductBatch[],
): ProductBatchItemState[];
function buildProductBatchItemState(data: ProductBatch | ProductBatch[]) {
  return Array.isArray(data)
    ? data.map(item => ({ ...item, checked: false }))
    : { ...data, checked: false };
}

export const loadProductBatchListAsync = createAsyncThunk(
  'productBatch/load',
  async () => {
    return await fetchProductBatchList();
  },
);
export const updateProductBatchAsync = createAsyncThunk(
  'productBatch/update',
  async (input: MutationUpdateProductBatchArgs['input']) => {
    return await updateProductBatch(input);
  },
);
export const createProductBatchAsync = createAsyncThunk(
  'productBatch/create',
  async (input: MutationCreateProductBatchArgs['input']) => {
    return await createProductBatch(input);
  },
);
export const splitProductBatchAsync = createAsyncThunk(
  'productBatch/split',
  async (input: MutationSplitProductBatchArgs['input']) => {
    return await splitProductBatch(input);
  },
);
// export const mergeProductBatchAsync = createAsyncThunk(
//   'productBatch/merge',
//   async (input: MutationMergeProductBatchArgs['input']) => {
//     return await mergeProductBatch(input);
//   },
// );
export const deleteProductBatchAsync = createAsyncThunk(
  'productBatch/delete',
  async (id: number) => {
    return await deleteProductBatch(id);
  },
);

export const productBatchSlice = createSlice({
  name: 'productBatch',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    openSplitProductBatchModal: (
      state,
      action: PayloadAction<{ item: ProductBatch; statusId: number }>,
    ) => {
      state.splitProductBatchForm = action.payload;
    },
    closeSplitProductBatchModal: state => {
      state.splitProductBatchForm = null;
    },
    toggleCheck: (state, action: PayloadAction<number>) => {
      const item = state.items.find(item => item.id === action.payload);
      if (!item) throw new Error('not found id');

      const index = state.items.indexOf(item);
      item.checked = !item.checked;
      state.items = update(state.items, {
        [index]: { $set: item },
      });
    },
    closeModal: state => {
      state.showModal = false;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: builder => {
    builder
      .addCase(loadProductBatchListAsync.fulfilled, (state, action) => {
        state.items = buildProductBatchItemState(action.payload);
      })
      .addCase(updateProductBatchAsync.fulfilled, (state, action) => {
        if (!action.payload) throw new Error('error 1');
        // @ts-expect-error
        let item = state.items.find(item => item.id === action.payload.id);
        if (!item) throw new Error('error 1');
        const index = state.items.indexOf(item);
        item = { ...item, ...action.payload };
        state.items = update(state.items, {
          [index]: { $set: item },
        });
      })
      .addCase(createProductBatchAsync.fulfilled, (state, action) => {
        if (!action.payload) throw new Error('error 1');

        state.items.push(buildProductBatchItemState(action.payload));
      })
      .addCase(splitProductBatchAsync.fulfilled, (state, action) => {
        if (!action.payload) throw new Error('error 1');
        const index = state.items.findIndex(
          item => item.id === action.meta.arg.id,
        );
        if (index == -1) throw new Error('error 1');
        state.items.splice(
          index,
          1,
          ...buildProductBatchItemState(action.payload.newItems),
        );
      })
      // .addCase(mergeProductBatchAsync.fulfilled, (state, action) => {
      //   if (!action.payload) throw new Error('error 1');
      //
      //   const index1 = state.items.findIndex(
      //     item => item.id == action.payload?.deletedProductBatchIds[0],
      //   );
      //
      //   state.items.splice(index1, 1);
      //   const index2 = state.items.findIndex(
      //     item => item.id == action.payload?.deletedProductBatchIds[1],
      //   );
      //   state.items.splice(index2, 1);
      //   state.items.splice(
      //     index1,
      //     0,
      //     buildProductBatchItemState(action.payload.parent),
      //   );
      //
      //   state.splitProductBatchForm = null;
      // })
      .addCase(deleteProductBatchAsync.fulfilled, (state, action) => {
        if (!action.payload) throw new Error('error 1');
        const item = state.items.find(item => item.id === action.payload);
        if (!item) throw new Error('error 1');
        const index = state.items.indexOf(item);
        state.items.splice(index, 1);
      });
  },
});

export const {
  openSplitProductBatchModal,
  closeSplitProductBatchModal,
  toggleCheck,
} = productBatchSlice.actions;

export const selectProductBatchList = (state: RootState) =>
  state.productBatch.items;
export const selectCheckedProductBatchList = (state: RootState) =>
  state.productBatch.items.filter(item => item.checked);
export const selectSplitProductBatchForm = (state: RootState) =>
  state.productBatch.splitProductBatchForm;
export const selectProductBatchShowModal = (state: RootState) =>
  state.productBatch.showModal;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
export const incrementIfOdd =
  (amount: number): AppThunk =>
  (dispatch, getState) => {
    // const currentValue = selectCount(getState());
    // if (currentValue % 2 === 1) {
    // dispatch(incrementByAmount(amount));
    // }
  };

export default productBatchSlice.reducer;
